<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>06 Prototypes | JavaScript Fundamentals</title>

    <link rel="stylesheet" href="../css/reveal.css">
    <link rel="stylesheet" href="../css/theme/zuehlke.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="../lib/css/atom-one-dark.css">

    <!-- Printing and PDF exports -->
    <script>
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ? '../css/print/pdf.css' : '../css/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>
</head>
<body>
<div class="reveal">
    <div class="slides">
        <section class="deck-slide">
            <h1>JavaScript Fundamentals<br>07 Prototypes</h1>
        </section>
        <section>
            <section>
                <h2>Prototypes</h2>
                <p>JavaScript is a prototype-based language, which means that each object has a prototype object.</p>
                <p class="fragment"><span class="warn">...what?</span></p>
            </section>
            <section>
                <h2>Prototypes</h2>
                <p>Think of Java, where every <span class="code">class</span> inherits from <span
                        class="code">Object</span>.</p>
                <p class="fragment">In JavaScript, every <span class="code">{ object }</span> has a <span class="warn">link</span>
                    to <span class="code">Object.prototype</span></p>
                <p class="fragment"><span class="warn">...what?</span></p>
            </section>
            <section>
                <h2>Try it out!</h2>
                <p>in the developer console. Have a close look at the output</p>
                <pre>
                <code class="hljs javascript" data-trim contenteditable data-noescape>
                    {};
                    const obj1 = {};
                    const obj2 = {};

                    Object.getPrototypeOf(obj1)
                        === Object.getPrototypeOf(obj2);

                    Object.prototype;
                    Object.prototype.constructor;
                </code>
                </pre>
            </section>
            <section>
                <h2>Prototypes</h2>
                <p>What have we learnt?</p>
                <ul>
                    <li>Every plain object has <span class="warn">the same</span> prototype object!</li>
                    <li><span class="code">Object.prototype</span> is the prototype assigned to all objects</li>
                    <li><span class="code">Object.prototype</span> contains many useful methods, which we can call on
                        all objects (eg <span class="code">toString()</span>)
                    </li>
                    <li><span class="code">Object.prototype</span> has a property <span class="code">constructor</span>
                        which points back to <span class="code">Object</span></li>
                </ul>
            </section>
        </section>
        <section>
            <section>
                <h2>The <span class="code">new</span> operator</h2>
                <p>You can put <span class="code">new</span> in front of every method call, turning it into a <span
                        class="code">constructor call</span>.</p>
                <pre>
                <code class="hljs javascript" data-trim contenteditable data-noescape>
                    const result = uselessFunction(); // returns undefined
                    const withNew = new uselessFunction(); // returns {} !

                    function uselessFunction() { }
                </code>
                </pre>
            </section>
            <section>
                <h2>The <span class="code">new</span> operator</h2>
                <p>What (roughly) happens behind the scenes when we call a function with <span class="code">new</span></p>
                <ol>
                    <li>A new empty object <span class="code">{ }</span> is created</li>
                    <li class="fragment">The function is called with <span class="code">this</span> bound to the new
                        object
                    </li>
                    <li class="fragment">The new object is returned</li>
                </ol>
            </section>
            <section>
                <h2>The <span class="code">new</span> operator</h2>
                <p>What happens behind the scenes when we call a function with <span class="code">new</span></p>

                <pre>
                <code class="hljs javascript" data-trim contenteditable data-noescape>
                    const myObj = new SomeFunction();
                    // does roughly this:
                    const obj = {};
                    SomeFunction.call(obj);
                    myObj = obj;

                    function SomeFunction() {
                        this.hello = 'World';
                    }
                </code>
                </pre>
                <div class="tip fragment">It is convention to capitalize functions which are intended as constructors.
                </div>
            </section>
            <section>
                <h2>The <span class="code">new</span> operator</h2>
                <p>Now have a look at your newly created object's prototype!</p>

                <pre>
                <code class="hljs javascript" data-trim contenteditable data-noescape>
                    const person1 = new Person(), person2 = new Person();

                    Object.getPrototypeOf(person1)
                        === Object.getPrototypeOf(person2);
                    Object.getPrototypeOf(Person.prototype)
                        === Object.prototype;

                    Person.prototype;
                    Person.prototype.constructor;

                    function Person() {
                        this.name = 'Freddy';
                    }
                </code>
                </pre>
            </section>
            <section>
                <h2>Prototypes</h2>
                <p>What have we learnt?</p>
                <ul>
                    <li>Every person has <span class="warn">the same</span> prototype object</li>
                    <li><span class="code">Person.prototype</span> is the prototype assigned to all person objects</li>
                    <li>There is a chain of prototypes up to <span class="code">Object.prototype</span>!</li>
                </ul>
            </section>
            <section>
                <h2>Prototypes</h2>
                <p>Conclusions:</p>
                <ul>
                    <li class="fragment">Every function has its own prototype object</li>
                    <li class="fragment">Prototypes are singletons</li>
                    <li class="fragment">Every object created from this function has that function's prototype linked to
                        it
                    </li>
                </ul>
            </section>
            <section>
                <h2>Prototypes</h2>
                <p>Conclusions:</p>
                <ul>
                    <li class="fragment">Any plain object <span class="code">{Â }</span> is basically the result of
                        calling <span class="code">new Object()</span>,
                        which is why it is linked to <span class="code">Object.prototype</span></li>
                    <li class="fragment">Since a function's prototype is an object, it has it's own prototype too, the
                        <span class="code">Object.prototype</span></li>
                </ul>
            </section>
            <section>
                <h2>But what does this even mean?</h2>
                <p>When trying to access a property on an object, the prototype chain is followed until that property is
                    found.
                    If it still isn't present on the topmost prototype (almost always <span class="code">Object.prototype</span>,
                    a <span class="code">ReferenceError</span> is thrown.</p>
            </section>
        </section>
        <section>
            <section>
                <h2>Creating "classes" with Prototypes</h2>
                <p>Now you have understood how prototypes work, so we can try to create our own "classes" and instances,
                    without using ES6 classes.</p>
                <p>Remember, JavaScript <span
                        class="warn">doesn't really know the concept of classes, only objects</span></p>
            </section>
            <section>
                <h2>"Classes"</h2>
                <pre>
                <code class="hljs javascript" data-trim contenteditable data-noescape>
                    const freddy = new Person('Freddy', 35);
                    const johnny = new Person('Johnny', 47);

                    function Person(name, age) {
                        this.name = name;
                        this.age = age;
                    }
                </code>
                </pre>
            </section>
            <section>
                <h2>"Classes"</h2>
                <p>Adding behaviour</p>
                <pre>
                <code class="hljs javascript" data-trim contenteditable data-noescape>
                    function Person(name, age) {
                        this.name = name;
                        this.age = age;
                    }

                    Person.prototype.sayHello = function() {
                        console.log(`Hi, I am ${this.name}
                            and I am ${age} years old.`);
                    }
                </code>
                </pre>
                <div class="tip fragment">Prototypes are singletons! Behaviour or even properties added to them apply to
                    all objects, even when added later!
                </div>
            </section>
            <section>
                <h2>Try it yourself</h2>
                <p data-height="459" data-theme-id="0" data-slug-hash="vRGVmM" data-default-tab="js,result"
                   data-user="enpayne" data-embed-version="2" data-pen-title="Prototypes" data-editable="true"
                   class="codepen">See the Pen <a href="https://codepen.io/enpayne/pen/vRGVmM/">Prototypes</a> by Nick Payne (<a href="https://codepen.io/enpayne">@enpayne</a>) on <a href="https://codepen.io">CodePen</a>.
                </p>
                <script async src="https://static.codepen.io/assets/embed/ei.js"></script>
            </section>
        </section>
        <section>
            <section>
                <h2>Object.create</h2>
                <p>We have learnt that when creating an object with a constructor call, it is automatically assigned
                 the constructor function's prototype.</p>
                <p>There is a way to create an object with <span class="warn">no</span> or a <span class="warn">custom</span> prototype: <span class="code">Object.create</span></p>
            </section>
            <section>
                <h2>Object.create</h2>
                <pre>
                <code class="hljs javascript" data-trim contenteditable data-noescape>
                    const objWithoutProto = Object.create(null);

                    const myOwnProto = {
                        sayHi: function() {
                            console.log('hi');
                        }
                    }

                    const person = Object.create(myOwnProto);
                </code>
                </pre>
            </section>
        </section>
        <section>
            <section>
                <h2>Inheritance</h2>
                <p>We have already seen how inheritance works in JavaScript.</p>
                <p><span class="warn">By prototype chains.</span></p>
            </section>
            <section>
                <h2>Inheritance</h2>
                <p>usually implies a <span class="warn">copy</span> action</p>
                <img src="../img/inheritance.png"/>
            </section>
            <section>
                <h2>Inheritance</h2>
                <p>... while in JavaScript, things aren't copied, but <span class="warn">linked</span>.</p>
                <img src="../img/prototypes.png"/>
            </section>
            <section>
                <h2>Inheritance</h2>
                <p>Base "Class"</p>
                <pre>
                <code class="hljs javascript" data-trim contenteditable data-noescape>
                    function Person(name, age) {
                        this.name = name;
                        this.age = age;
                    }
                </code>
                </pre>
            </section>
            <section>
                <h2>Inheritance</h2>
                <p>Child "Class"</p>
                <pre>
                <code class="hljs javascript" data-trim contenteditable data-noescape>
                    function Student(name, age, studentId) {
                        Person.call(this, name, age);
                        this.id = studentId;
                    }

                    Student.prototype = Object.create(Person.prototype);
                    Student.prototype.constructor = Student;
                </code>
                </pre>
            </section>
            <section>
                <h2>Inheritance</h2>
                <p>Try it out yourself in the console!</p>
                <pre>
                <code class="hljs javascript" data-trim contenteditable data-noescape>
                    function Person(name, age) {
                        this.name = name;
                        this.age = age;
                    }

                    function Student(name, age, studentId) {
                        Person.call(this, name, age);
                        this.id = studentId;
                    }

                    Student.prototype = Object.create(Person.prototype);
                    Student.prototype.constructor = Student;
                </code>
                </pre>
            </section>
            <section>
                <h2>Inheritance</h2>
                <p>TODO draw a diagram of the inheritance we just did</p>
            </section>
            <section>
                <h2>Inheritance</h2>
                <p>Since ES6 classes, this behaviour is hidden</p>
                <pre>
                <code class="hljs javascript" data-trim contenteditable data-noescape>
                    class Person {
                        constructor(name, age) {
                            this.name = name;
                            this.age = age;
                        }
                    }

                    class Student extends Person {
                        constructor(name, age, studentId) {
                            super(name, age);
                            this.id = studentId;
                        }
                    }
                </code>
                </pre>
                <div class="tip fragment">The language still doesn't know the concept of classes. This is just syntactical sugar to hide the pattern we looked at before.</div>
            </section>
        </section>
    </div>
</div>
<script src="../lib/js/head.min.js"></script>
<script src="../js/reveal.js"></script>

<script>
    // More info https://github.com/hakimel/reveal.js#configuration
    Reveal.initialize({
        history: true,

        // More info https://github.com/hakimel/reveal.js#dependencies
        dependencies: [
            {src: '../plugin/markdown/marked.js'},
            {src: '../plugin/markdown/markdown.js'},
            {src: '../plugin/notes/notes.js', async: true},
            {
                src: '../plugin/highlight/highlight.js', async: true, callback: function () {
                    hljs.initHighlightingOnLoad();
                }
            }
        ]
    });
</script>
</body>
</html>
